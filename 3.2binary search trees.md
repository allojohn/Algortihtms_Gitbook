当传统的二分搜索出现局限时，我们需要另一个更加合适的算法，这便是Binary Search Trees，它在搜索时和二分搜索完全相同。但是在二分搜索所不擅长的方面，它存在优势。比如，我们看到，它在增加数据的时候，并不是将所有的数据都移动一次，而是当需要增加一个新的数据是，它在对应的节点增加，完全不需要移动。二分搜索的限制扎根于线性排序，所以增加节点时，之后的节点都需要移动。而BST没有再沿用这一想法。他们做的，并不是线性有序，而是另一个层次上的有序。当往其中增加节点时，我们做的，是在其中添加一些非常合适的东西，例如，现有的内容，有1，4，5，那我们在添加一个新的数时，就需要做到一下的形式：先比较1，再比较4，再比较5，然后增加10.那当我们需要增加3的时候，我们先比较1，然后再比较4，然后因为4没有左节点了，所以我们在这里添加一个新的数。那么，我们在表示这个时候，使用的其实是链表的数据结构。我们没有使用到数组。另一方面，当我们开始使用到删除操作的时候，我们有什么要注意的呢？其实还是和刚才的搜索过程完全相同，最终，我们找到的，是一个非常合适的过程。
那么，我们如何去评价整个过程的时间复杂度呢？我们可以看到，很有可能，我们只需要查找lgN次数据。层高就是我们查找的次数。但是这其实很牵强，因为我们讨论的是一种理想情况。我们不知道这个数到底是不是非常平衡。像之前的例子，当我们连续添加1 4 5 8 10  20 时，最终形成的数，实际上是线性的。它完全没有达到最好的效果。因此，我们需要一个更加高效的算法。

因此，当我们开始考虑BST到底出了什么问题时，我们看到，最大的问题，在于它不能自动让生成的树保持平衡。如果一个树形结构能够在生成的过程中一直保持平衡，那么我们就可以确保lg级别的复杂度。

这便是2-3平衡树的理念。在这之前我们强调一下，2-3平衡树只是一个用于思维的模型，它在帮助思考的时候很方便，但是在实现的时候，我们用的，是另一种表征方式来模拟这样的过程。这便是红黑树的概念。

