### 优先队列
在之前的排序中，我们做的是对全体数据对象做一个排序，然而有时候，我们其实并不像知道全体的信息，例如，在一万条数据中，最大的10个数据是哪几个。在这种情况下，便需要用到优先队列。它值需要考虑排名最靠前的数据是哪几个。

### 优先队列的实现方式
优先队列的实现方式也可以分为几个类型。最基本的分类是通过数组与链表来划分。并且可以进一步分为有序与无序队列。具体的比较如下：
#### 有序数组
有序数组，顾名思义，就是数据在其中按顺序排列。然而就像之前我们在第二章看到的那样，数组的好处，是查找、比较非常方便，然而如果要对数组本身做修改，则需要常数级别的复杂度，因此这样实际上很不方便。
#### 无序数组
无需数组相对于有序数组来说，好处在于它可以很方便地对数组元素做修改， 时间复杂度为常数级别。然而它的缺点是我们在查找的时候 很麻烦，需要逐个查找。
#### 有序链表
有序数组在执行比较的过程汇总可以使用二分操作，而链表则需要逐个查找。不过它的在修改时比较容易，只需要插入一个新的节点。
#### 无序链表
无序链表的问题····各种不方便。增删改查中，只有增加操作比较方便。
#### 总结
可见，简单的数组/链表与有序/无序的结合，远远不能满足我们的要求，我们在多种操作中都能够发挥完美的算法与数据类型。

### 堆
#### 堆的特点
堆初看起来很像是二叉树，但堆只是**部分有序**。这一有序表现为不同层级结构上的大小关系确定、同层的大小关系不定。
，我们使用数组来表示堆，并且默认从1开始。

#### 堆中的常见操作
我们在实现的过程中，使用数组来表示堆。并且在这样的过程中，数组从1开始，而不是0。在这样的情况下， 堆便具有以下性质：一个节点如果被标记为x，则它的父节点的索引为[x/2],例如，如果它的索引是10，则它的父节点便是5，同样，索引为11,则父节点也为5。这便引出了另一个等价的结论：一个节点的孩子节点是x * 2 与 x * 2 + 1。
有了这样的结论，我们便可以比较方便地操作堆了。常见的对堆的比较与排序有一下两种操作：
1. swim。当我们添加一个节点是，我们可以使用这样的操作对其排序。它不断比较该节点与父节点的大小， 如果满足条件则交换位置，并继续这样的操作。这道该条件不再满足位置。
2. sink。
sink操作一般在删除、初始化数组的顺序、排序中使用。
它将最顶层的节点与数组末端的节点交换。在交换后，通过不断比较子节点中的最大值，进一步交换。
