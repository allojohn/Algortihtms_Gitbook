搜索的特点。
关于搜索类型的划分，可以有那几点恩？
分为有序与无序。这是一个简单的划分，我们想尝试如此，然后在进行迭代。
其中一部分，便是二分搜索。然而二分搜索存在很强的限制:它只能被用所搜索有限序列。好处是，在lgN的时间复杂度下可以完成。
至于hash，其实是一个映射的方式来完成：我们给定一个对应的名称，然后在这样的名称下， 寻找相关的值。这里的问题就是，如果我们寻求简单的计算，那么我们在就可以出现一个矛盾：我们最终的值可能不是一一映射 的关系，那应该怎么去解决呢？
对此，首先想到的， 是先提供一个白名单，专门在其中存储一些与例外有关的内容，现在其中查找。另一个方法，是用链表的方式来解决。让它指向另一个点，如果指向的链表中的指针为空，说明需要进一步查找。这是，我们可以在这里做一个额外处理，解决这样的问题。总之，我们要试图处理的，是这样的一堆矛盾：我们试图使用费海沧简单的方法去将编码， 但是编码的简单却又会带来新的问题：发生重复了则呢么办呢？

对于另一个类型，则是我们之前考虑过的BST:binary search trees。它有设么样的特点呢？我们在创建的时候我，我们在创建的时候，逐个建造了这些书。但是这些树并不是随随便便建造的，而是有一个确定的规则。对于BST来说，我们创建的规则就是，尝试在整个过程中使用比较简单的计算，将整个过程映射成树的形状，并且他们是完全有序的。一个节点的left，是比它小的值，right节点，是比它大的值。这样，当我们在搜索的时候，我们可以做到非常快速地进行比较。然而问题在于，我们无法做到平衡：我们希望最上层的节点是整个数组的中位数，但是BST并没有做到。它只是确立了大小关系，至于树型的进一步安排，则需要进一步考虑。
同时，我们也需要考虑几方面的问题：我们在考虑搜索的时候，有哪些是值得我们关注的？
例如，只有有序的树形结构，才适合我们去使用BST。所以，它们都是定制的，我们在创建的时候，就需要特定的、与搜索算法玄关的创建算法。因此，它们之间并不能相互随便使用。
